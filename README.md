1. synchronized 키워드
설명
Java에서 가장 기본적인 동기화 방법으로, 메서드나 블록에 synchronized를 선언하여 한 번에 한 스레드만 접근하도록 제한.

모니터 락(monitor lock)을 사용하여 임계 영역(critical section)을 보호.

장점
구현이 매우 간단하며 문법적으로 직관적임.

JVM에서 기본 지원하므로 별도의 라이브러리 필요 없음.

객체 단위 락을 이용해 간단한 동기화 요구사항에 적합.

단점
락 해제 지점을 개발자가 제어할 수 없어, 잘못 사용 시 데드락 발생 위험.

락 경쟁이 심할 경우 전체 성능 저하가 발생할 수 있음.

공정성 보장 안됨 (스레드가 언제 락을 얻을지 예측 불가).

락 범위가 크면 병목 발생 가능.

2. java.util.concurrent.locks.ReentrantLock
설명
Lock 인터페이스 구현체 중 하나로, synchronized보다 세밀한 락 제어 가능.

락 획득과 해제 시점 직접 제어 가능 (lock()/unlock()).

공정성 옵션 설정 가능.

장점
공정성(fairness) 옵션으로 락 요청 순서 보장 가능.

조건 변수(Condition)를 통한 스레드 간 통신 지원.

락 획득 시도, 타임아웃 기능 제공으로 유연한 동기화 가능.

synchronized보다 세밀한 제어가 필요할 때 적합.

단점
코드 복잡도 증가 (반드시 unlock() 호출 보장 필요).

unlock 호출 누락 시 데드락 발생 위험.

문법적으로 다소 불편하고 예외 처리 코드가 필요.

3. java.util.concurrent.atomic 패키지 (Atomic 변수들)
설명
CAS (Compare-And-Swap) 기반의 원자적 연산을 제공하는 클래스들 (AtomicInteger, AtomicLong, AtomicReference 등).

락 없이 동시성 제어가 가능.

장점
락을 사용하지 않아 컨텍스트 스위칭, 락 경합 비용 감소.

매우 높은 성능과 낮은 지연 시간.

단순한 원자적 연산에 적합 (카운터, 플래그 등).

단점
복잡한 연산이나 임계영역 보호에는 부적합.

여러 변수를 동시에 원자적으로 업데이트하는 복합 작업에는 한계.

무한 루프(CAS 실패 시 재시도) 가능성으로 CPU 자원 소모 발생 가능.

