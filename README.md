# 동시성 제어 방식 및 각 적용의 장/단점 분석 보고서


### 1. synchronized

####  설명
Java에서 가장 기본적인 동기화 방법으로, 메서드나 블록에 synchronized를 선언하여 한 번에 한 스레드만 접근하도록 제한합니다. 모든 사용자가 직렬 처리되어 전체 시스템의 처리량이 제한됩니다.

####  장점
- **간단한 문법**: 코드 작성이 직관적이고 이해하기 쉬움
- **JVM 기본 지원**: 별도의 라이브러리 없이 객체 단위 락을 쉽게 구현 가능
- **자동 락 관리**: 블록 종료 시 자동으로 락 해제되어 메모리 누수 방지
- **기본적인 동기화**: 일반적인 동기화 요구사항에 충분히 적합

####  단점
- **제한적인 제어**: 락 해제 시점을 개발자가 직접 제어할 수 없어, 잘못 사용 시 데드락 위험
- **성능 저하**: 락 경쟁이 심하면 전체 성능 저하 발생
- **공정성 미보장**: 락의 공정성(fairness)이 보장되지 않아 스레드가 언제 락을 얻을지 예측 불가
- **병목 현상**: 락 범위가 크면 전체 시스템의 병목 현상 유발 가능

### 2. ReentrantLock 

####  설명
Lock 인터페이스 구현체로, 사용자 간 병렬 처리를 가능하게 하면서 각 사용자 내에서는 직렬 처리를 보장합니다. 사용자별로 독립적인 락을 관리하여 전체 시스템의 처리량을 극대화할 수 있습니다.

####  장점
- **공정성 옵션**: 생성자 매개변수로 락 요청 순서 보장 가능 (`new ReentrantLock(true)`)
- **유연한 락 제어**: `tryLock()`, 타임아웃 설정 등 다양한 락 획득 방식 지원
- **Condition 지원**: 스레드 간 통신 및 대기/신호 기능 제공
- **세밀한 제어**: 락 범위를 정확히 제어하여 성능 최적화 가능
- **인터럽트 지원**: 락 대기 중인 스레드를 인터럽트할 수 있음

####  단점
- **복잡한 코드**: try-finally 구조로 인한 코드 복잡도 증가
- **락 해제 누락 위험**: 수동 락 해제로 인해 finally 블록에서 unlock()을 누락하면 데드락 발생
- **메모리 오버헤드**: synchronized보다 메모리 사용량이 많음
- **성능 오버헤드**: 간단한 동기화에서는 synchronized보다 느릴 수 있음


####  병렬성의 핵심 개념
- **사용자 간 병렬 처리**: 사용자 A, B, C가 동시에 포인트 충전 가능
- **각 사용자 내 직렬 처리**: 사용자 A의 충전 → 사용 → 충전이 순차적으로 처리
- **데이터 일관성 보장**: 동일 사용자의 데이터 레이스 컨디션 방지

---

### 3. Atomic 클래스

####  설명
CAS(Compare-And-Swap) 기반의 원자적 연산을 제공하는 클래스들(AtomicInteger, AtomicLong, AtomicReference 등)로, 락 없이 동시성 제어가 가능합니다.

####  장점
- **높은 성능**: 락을 사용하지 않아 컨텍스트 스위칭 및 락 경합 비용 감소
- **낮은 지연시간**: 즉시 연산 수행으로 대기 시간 없음
- **단순 연산 최적화**: 카운터 증가, 플래그 설정 등 단순 연산에 최적화
- **데드락 없음**: 락을 사용하지 않아 데드락 발생 가능성 원천 차단
- **스케일링**: 멀티코어 환경에서 우수한 확장성

####  단점
- **제한적 사용**: 복잡한 연산이나 임계 영역 보호에는 적합하지 않음
- **복합 연산 한계**: 여러 변수를 동시에 원자적으로 업데이트하는 복합 작업에 한계
- **CPU 자원 소모**: CAS 실패 시 무한 재시도 루프로 인해 CPU 자원 소모 가능
- **메모리 가시성**: 단순 읽기/쓰기 외의 복잡한 메모리 가시성 보장 어려움

